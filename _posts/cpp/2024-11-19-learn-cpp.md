---
layout: post
tags:
  - Cpp
---
<https://www.learncpp.com/>
## Intro
Lang stack looks like
1. Machine lang, x86 or arm that only specific CPUs can understand
2. (Assembler converts ass lang into machine lang)
3. Assembly lang, human readable machine lang (also machine specific)
4. (Compiler and or interpreter)
5. High level lang

Cpp stack looks like [info](<https://en.cppreference.com/w/cpp/language/translation_phases)>
1. Source file
2. (Preprocessing)
3. (Compiler)
4. object files: machine language
5. (Linker)
6. Link all these object files together into a exe or a lib
## Basics
By default `int width = 5` assignment copies the value to right side to the variable of left side, it's doing a copy-assignment. Copy initialisation has an overhead, and is used for function parameter and returns.

Can also do other initialisation syntax.
```cpp
int d { 7 };   // direct-list-initialization (initial value in braces)
int e {};      // value-initialization (empty braces), set to 0

// And the crappier direct initialisation
int f (4);
// List init disallows narrowing conversions! Beautiful!
int f (4.5); // somehow allowed?
```

Maybe a little surprising is that `x = 5` and `cout << 5` are both operators and can be chained like a `+`.
## Basics: functions and files
When returning from main you need to pull in some preprocessor macros to return.
```cpp
#include <cstdlib> // for EXIT_SUCCESS and EXIT_FAILURE

int main() {
    return EXIT_SUCCESS;
}
```

Compiler declarations.
- If you're defining two functions, because the compiler works sequentially line by line you need to declare functions you're going to use before you use them. Sometimes this isn't possible with cyclic definitions. You can avoid this by having a function prototype declared ahead.

```cpp
#include <iostream>
using namespace std;

int add(int x, int y);

int main(){
    cout << add(5,6) << "\n";
    return 0;
}

int add(int x, int y){
    return x + y;
}
```

Cpp has namespaces, it was a shit show having all the function names being hogged up by stdlib functions, so these were moved to the `std::` namespace. yay!

Before compilation there is a preprocessing phase, that converts source code into translation units that are passed to the compiler.
- Processes those directives e.g `#include <iostream>` and macros `#define`.
- You can do if statements on these macro defines to choose what code gets compiled.

Header files are just files which have a bunch of forward declarations that the preprocessor will include in the file for us.
- You should have a header guard so that your header is only inlined once
- Best practice is to include the corresponding h file in the corresponding cpp file. To catch compilation errors early.

```cpp
#ifndef SQUARE_H
#define SQUARE_H

int getSquareSides()
{
    return 4;
}

#endif
```
## Debugging
Consider printing to `cerr <<` instead of `cout` as it's unbuffered so will always be emitted to out.

Consider doing linting.
- <https://clang.llvm.org/extra/clang-tidy/>
- <https://github.com/cpplint/cpplint>
- <https://cppcheck.sourceforge.io/>

## Fundamental data types
Incomplete types are types that are declared but not defined with a set amount of memory to allocate, e.g void.

Be careful with implicit conversions, especially between unsigned and signed integers!

Base ints actually have undefined bounds depending on architecture as they only have a defined min of 16 bits, this is crap, fixed in cpp11 with fixed width integers `int32_t`. But as it's not guaranteed that the smallest bounded ints are the fastest there's even types that will just choose the fastest one for you, `int_fast32_t`.

Can write stuff in scientific notation `1.2 x 10^4 = 1.2e4`.

Cpp does implicit type conversion everywhere, unsurprisingly type conversion creates new values. Implicit conversion happens on copy assignment, function parameters and returns. Brace initialisation prevents implicit type conversion. yay!
## Constants and strings
Cpp has two types of constants, Named and literal constants.

On named consts, just do below. These are called type qualifiers.
```cpp
const int temp {5};
```

You can also have literal constants. These can be specialised by adding those suffixes for a specific literal type. e.g 5.0f.

List of compiler optimisations.
- <https://en.wikipedia.org/wiki/Optimizing_compiler#Specific_techniques>
- Compiler will evaluate some expressions to speed things up!

On compiler time evaluation, whether something is a constant expression matters, main sharp edge here is that even tho const double has the word const only const integral variables are constant expressions. To avoid this sharp edge just use constexpr!
```cpp
constexpr double gravity {9.8};
```
But this doesn't work if you just call a function, so you can also declare functions to use this so that it is allowed to run at compile and runtime. Define these in your header files if used across a project as they are implicitly inline.
```cpp
constexpr int bing(){
	return 5;
}
```
Now these constexpr functions just signal that the function can be evaluated compile time. How can we declare that it must be evaluated only at compile time? With consteval!
```cpp
// CPP20
consteval int bong(){
	return 6;
}
```

Compilers also inline function to remove the function call overhead when possible. This does have issues, as compiler works on a per file basis it can't inline stuff in other translation units. To fix this issue you can use the `inline` keyword on functions to declare that they can be defined in multiple translation units and the linker will dedupe as necessary, just shove them into your header files.

Cpp has c style strings and you should try to avoid them as they have a set of sharp edges, especially on assignment between them. Just use `std::string` and `std::string_view`. String will dynamically allocate more memory if it needs more space.
- Don't forget to cast length as it'll be unsigned.
- Do not pass strings by value, thats expensive!

Key thing to remember is that fundamental type copies are fast and Compound types are slow. To fix this string being expensive, cpp17 has `std::string_view in <string_view> .h`. This is a readonly string, especially nice to avoid cost in function parameters. Also has downsides, it is just viewing a string so when that string is destroyed it will just be dangling viewing at something undefined.

Functions return temporary objects that auto destroy at the end of the full expression containing the function call! keep that in mind!
## Operators
Pre and postfix operators, the prefix one returns the incremented thing, postfix just returns a temporary copy of the non incremented thing. Just use prefix operator!
```cpp
#include <iostream>

int main()
{
    int x { 5 };
    int y { 5 };
    std::cout << x << ' ' << y << '\n';
    std::cout << ++x << ' ' << --y << '\n'; // prefix
    std::cout << x << ' ' << y << '\n';
    std::cout << x++ << ' ' << y-- << '\n'; // postfix
    std::cout << x << ' ' << y << '\n';

    return 0;
}
```
## Bit manipulation
Smallest addressable unit of memory is a byte, so bools are pretty inefficient, lets pack these values into bitsets and unsigned ints.
- Bitset doesn't even save space for small collection of bools, will just allocate more bytes to be faster.
- When using shorts, theres a foot gun where bitwise operators will promote your types to ints. This will make some weird stuff with width dependant operations, `~ and <<`. So do static casts!

When touching bits you can use binary literal constants. `0b0101`! Only on cpp17.
## Scope, duration and linkage
To avoid name collisions, you can define your own namespaces.
- Best practice being using capitalised namespaces.
- Hit relevant namespace from global with `Foo::doSomething()`
- Hit global from within a namespace with `::doSomething()`
```cpp
namespace Foo // define a namespace named Foo
{
    // This doSomething() belongs to namespace Foo
    int doSomething(int x, int y)
    {
        return x + y;
    }
}
```

## Control flow
## Error detection and handling
## Type conversion, type aliases and type deduction
## Function overloading and function templates
## Compound types: references and pointers
## Compound types: enums and structs
## Classes: intro
## Classes: more stuff
## Dynamic arrays: vector
## Fixed arrays: array, c-style
## Iterators and algorithms
## Dynamic allocation
## Functions
## Operator overloading
## Move semantics and smart pointers
## Object relationships
## Inheritance
## Virtual functions
## Templates and classes
## Exceptions
## Input and Output
## Misc
## Cpp versions
