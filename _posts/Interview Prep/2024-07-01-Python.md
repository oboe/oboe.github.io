---
tags:
  - Python
layout: post
---

<https://docs.python.org/3/tutorial/index.html >

## Python Interpreter

- [ ] What is the python global interpreter lock?

## Basics

```
In interactive last printed expression is assigned to variable `_`

Theres no char type in python.

You ca slice with word[0:2] a->b(excluded)

strings are immutable, so you need to recreate them

use len(word) for strings

collections are called compound data types

list = [1,2,3,4]

simple assignment is by reference

print(a, end=',') to avoid newlines

```
## Control flow

```
dogs = {'bob':'corgi','jeff':'wolf'}
for key,val in dogs.copy().items():
	print("yay I'm iterating")

Your standard for loop!
for i in range(len(n)):
	print(i)

for a,b in enumerate(values):
	print(a,b)

range() looks like it creates a list but it ISNT! 
ITS AN iterable!
<https://docs.python.org/3/glossary.html#term-iterable >

use pass to fill a unimplemented body.

DEFINING FUNCTIONS!
- executing a function adds a new symbol table for the local vars
- so all vars check the local symbol table, then the outer one, then global, then built-in ones.
- this means if you assign x=2 in a func, and a global x is defined it'll just create a new func in the function symbol table. You need to pull in the global one using `global x`
- The function parameters are actually added to the local symbol table of the called func, it's call by value!
- function definitions are also inserted in the relevant symbol table.
- functions always just return None

function defaults are only evaluated once, this accumulates values, mega JANK
def f(a,L=[]):
	L.append(a)
	return L

if you want to get arbitrary info through your python functions
- getting tuple `*arguments`
- getting dict `**keywords`

want to provide a func elements from a list? args = [1,2] then use range(*args). Same can be done with dicts.
```

## Data structures
```
List is actually a dynamic array.

deque exists

squares = [x**2 for x in range(10)]
tada

use `del` to delete elemnts from a list by index

<https://docs.python.org/3/library/stdtypes.html#typesseq>
Sequences
1. Lists
2. Tuples
3. Ranges

sequence unpacking is possible yay!

here's a set() or second_set = {1,2,3}
Can also do set comprehensions, nice

and use dict() tada
- del mp[a]
- list(mp)
- sorted(mp)

<https://docs.python.org/3/faq/design.html#why-can-t-i-use-an-assignment-in-an-expression>
while var := f(x):
	print(var)
Assignment within conditionals can be done, kinda JANK

```
## Modules
```
File name is the module name, access with __name__

importing module
- Does not bring the module functions into namespace, just the module

Each module has own private, but accessible namespace.

You can also directly import certain names from a module into your namespace
from fibo import a, b
- this is bad practice, dont do it!

Each module can only be imported once per interpreter session.

If you run a call python, it'll just call your module but with __name__ set to __main__.
- So you can check if code is ran like a script using 
if __name__ == "__main__":
    print("yo")

when import happens
1. checks for sys.builtin_module_names 
2. checks for a module.py file in sys.path

Python caches compiled version of each module into __pycache__
- these are module-version.pyc

Find out names a module defines with dir()

PACKAGES
- Lets you do A.B dotted module names, so you can write modules without giving a shit about other module definitions.
- __init__.py files are required to make python treat directories containing file as pacakges. 
- in the init, define __all__ to support `from numpy import *` to import whats necessary

SHADOWING
- Is when you import function with name that already defined.
```
## Input and Output
```

```

## Errors and Exceptions

## Classes

## Standard Library

## Virtual Environment and packages

## Floating point arithmetic
